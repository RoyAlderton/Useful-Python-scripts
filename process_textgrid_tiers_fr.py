# -*- coding: utf-8 -*-
"""
Created on Thu May 12 13:35:28 2022

@author: Roy Alderton

This script takes a folder of Praat TextGrids generated by the 'B2P -> MAUS -> 
PHO2SYLL' pipeline in BAS Web Services for French and does the following:
    
    1. Renames the tiers with more intuitive names.
    2. Removes two unnecessary tiers.
    3. Adds a new tier called 'PHRASE' with three intervals. The first and
    third interval contain no text, while the second interval contains the
    text 'phrase'. Its boundaries correspond to the beginning and end of the
    region of interest in the stimulus. In the case of French, this is the
    beginning of the [e] in 'Cléo' and the end of the target nasal sound or
    its oral counterpart.
    4. Makes a number of changes to specific intervals to fix frequent errors 
    made by MAUS when transcribing. The fixes required for French here are
    much more extensive than those needed for German (dealt with in the 'de'
    version of this script.)
      
The script should be saved in a folder with a sub-folder called 'TextGrids',
where the TextGrids to be processed should be located. You can then use the
P_text-grid-reviewermitZoom.praat Praat script to view (and edit) the TextGrids
and their corresponding WAV files at the same time.
 
Warning: the script will over-write the original TextGrids!

The script should be run in the command line by navigating to the correct
folder and entering a command in the following format:
    
    python process_textgrid_tiers_fr.py
    
If using Linux, you may need to replace 'python' with 'python3'.

You may not be able to run this file from the IPS server, in which case,
just copy everything to your computer and run it locally.

You may need to install the textgrids library if it isn't already on your
computer. You can do this by entering the following into the command prompt:
    
    pip install praat-textgrids
    
There is currently a bug in the library's set-up files that causes some Windows
computers to fail to install the library correctly via pip. If this occurs,
download the library as a zip file from the project's GitHub page and then 
extract it manually to the relevant folder in your computer's Python 
installation. See links below for details.

https://github.com/Legisign/Praat-textgrids
https://youtu.be/DKR0VYSOqLc

"""
# import required libraries
import os
import re
import textgrids

def fix_sound_syllable(interval):
    """
    Applies simple transcription corrections to intervals in the the sound and
    / or syllable tiers of the French nasality TextGrids by replacing the text.

    Parameters
    ----------
    interval : object class of an IntervalTier from the textgrids library
        The interval whose text you want to edit. See the library documentation
        for details on interval objects.

    Returns
    -------
    None.

    """
    if 'lane' in file or 'lame' in file:
        interval.text = interval.text.replace('A', 'a')
    elif 'Yann' in file:
        interval.text = interval.text.replace('a~', 'a')
    elif 'noeud' in file:
        interval.text = interval.text.replace('9', '2')
        interval.text = interval.text.replace('n 2 d', 'n 2')
    interval.text = interval.text.replace('a~', 'A~')
    interval.text = interval.text.replace('o~', 'O~')
    interval.text = interval.text.replace('9~', 'E~')
    interval.text = interval.text.replace('e~', 'E~')
    interval.text = interval.text.replace('o z', 'o') # for [k l e][o z] in the syllable tier
    interval.text = interval.text.replace('l a j', 'l e') # this line for "l'aîné" doesn't work as intended because of problems with the l' part of the syllable tier editing


# Specify folder path where the TextGrids are located
source_path = "TextGrids/"

# Get a list of TextGrid files in the folder
dir_list = os.listdir(source_path)
tg_list = [file for file in dir_list if 'practice' not in file and file.endswith('.TextGrid')]

# For each TextGrid file in the list...
for file in tg_list:
    
    # Load the file as a TextGrid in Python
    tg = textgrids.TextGrid(source_path + file)
    
    
    ### Apply basic steps (steps 1-3 from the preamble)
    
    # Delete the unneeded tiers
    del tg['KAN-MAU']
    del tg['KAS-MAU']
    
    # Rename the word tier
    tg['WORD'] = tg.pop('ORT-MAU')
       
    # Get the end time of the final interval on the sound (MAU) tier.
    # This is so that the end time of the new phrase tier can be specified 
    # correctly.
    file_end = tg['MAU'][-1].xmax
    
    # Get the start time of all [e] intervals on the sound (MAU) tier.
    # The first of these (corresponding to the [e] in 'Cléo') will be used as 
    # the start of the 'phrase' interval on the phrase tier.
    e_start_time = []
    for interval in tg['MAU']:
        if interval.text == 'e':
            e_start_time.append(interval.xmin) 
    #print(e_start_time)
    
    # Get the end time of the target nasal / oral interval on the sound (MAU) 
    # tier.
    # This will be used as the end of the 'phrase' interval on the phrase tier.
    nasals_orals = ['a~', 'a', 'e~', '9~', 'E', 'o~', 'O', 'n', 'm', 'J', 'p', 't', 'k', ]
    nasal_oral_end_time = []
    for interval in tg['MAU']:
        if interval.text in nasals_orals:
            nasal_oral_end_time.append(interval.xmax)
    #print(nasal_oral_end_time)

    # Specify the three intervals for the new phrase tier
    
    # The first item (index [0]) in e_start_time is used, i.e. the [e] in
    # 'Cléo'. This is because some items have another [e] later (e.g. 'l'année').
    
    # For most files, the third item (index [2]) in nasal_oral_end_time is used.
    # This is because all items have a [k] in Cléo, then an [a] in à, then the 
    # target, then potentially more of the same sound (e.g. another [k] in 
    # 'lac'), then the [m] in 'samedi'. However, these other sounds always come
    # after our target sound in the region of interest, so index [2] is reliable.
    
    # The extra_sound_files list refers to files that require the boundary
    # between the second and third intervals to match the fourth item (index [3])
    # in nasal_oral_end_time. This is because they have an extra vowel before
    # the target sound. The word 'lotte' appears in both the nasal vowel and
    # nasal consonant sets, which have different requirements for the region
    # of interest (it ends after the vowel for the former and after the 
    # consonant for the latter).
    
    # If a word is in the extra_sound_file list, the index changes from 2 to 3.
    
    # Specify the file names that require a different index number as above
    extra_sound_files = ['fin_or_p13_lotte', 'Alain', 'allais', 'Yann', 'homme', 'latte', 'yack', 'lac', 'anis', 'lapis', 'lannee', 'lathee', 'laine']
    
    # Specify the default index number
    variable_index = 2
    
    # Change the index number if the file is one of those in extra_sound_files
    for string in extra_sound_files:
        if string in file:
            variable_index = 3
            break
    
    # Create the three intervals for the phrase tier
    interval_1 = textgrids.Interval(text = '', xmin = 0.0, xmax = e_start_time[0])
    
    interval_2 = textgrids.Interval(text = 'phrase', xmin = e_start_time[0], xmax = nasal_oral_end_time[variable_index])
    
    interval_3 = textgrids.Interval(text = '', xmin = nasal_oral_end_time[variable_index], xmax = file_end)
    
   
    # Create the new phrase tier with the three intervals
    tg['PHRASE'] = textgrids.Tier(data = [interval_1, interval_2, interval_3])
               
    # Over-write empty labels on the word tier with '<p:>'
    for interval in tg['WORD']:
        if interval.text == '':
            interval.text = '<p:>'
    
    # Rename the sound and syllable tiers
    # This has to be done last to preserve the tier order.
    tg['SOUND'] = tg.pop('MAU')
    tg['SYLLABLE'] = tg.pop('MAS')
    
    
    ### End of basic steps
    
    
    ### Change specific intervals on the sound and syllable tiers
        
    # Make simple transcription fixes in the sound and syllable tiers
    # for some reason, putting this line in the main for-loops sometimes does not work
    # for words with "l'", so it has to go here separately instead.
    for interval in tg['SOUND']:
        fix_sound_syllable(interval)
    
    for interval in tg['SYLLABLE']:
        fix_sound_syllable(interval)
           
    ## Sound tier
    for count, interval in enumerate(tg['SOUND']):
       
        # yack - replace [i] with [j]
        if 'yack' in file and tg['SOUND'][count - 1].text != 'd': # avoid 'i's in 'dis' and 'samedi'
            interval.text = interval.text.replace('i', 'j')
            
        # l' - remove following schwa [@]
        # Cléo - remove following [z] 
        # samedi - remove schwa [@] before [d]
        # nœud - remove following [d]
        if (interval.text == '@' and tg['SOUND'][count - 1].text == 'l') or interval.text == 'z' or (interval.text == '@' and tg['SOUND'][count + 1].text == 'd' and tg['SOUND'][count - 1].text != 'Z') or (interval.text == 'd' and tg['SOUND'][count - 1].text == '2'): # if those intervals appear...
            index_no = count # save index of this interval, as this will be needed to save the new one
            new_boundary = interval.xmax # get time of right boundary of this interval
            removed_interval = tg['SOUND'].pop(count) # remove this interval
            tg['SOUND'][index_no - 1].xmax = new_boundary # over-write the previous interval's right boundary with the one from the removed interval   
    
        # l'enfer - replace [e] with [E] and add [R]
        if 'lenfer' in file and tg['SOUND'][count - 1].text == 'f':
            index_no = count # save index of this interval, as this will be needed to add the new one
            interval.text = interval.text.replace('e', 'E') # replace vowel
            duration_proportion = interval.xmin + interval.dur * 0.67 # define the boundary between the current interval and its new neighbour to the right as a certain proportion of its current duration
            tg['SOUND'].insert(index_no + 1, textgrids.Interval(text = 'R', xmin = duration_proportion, xmax = interval.xmax)) # insert a new interval to the right of the current interval, using the proportion defined earlier as its left boundary, and the right boundary of the current interval as its right boundary
            interval.xmax = duration_proportion # update the right boundary of the current interval to match the left boundary of its new neighbour to the right
            
        # l'aîné - replace [a] with [e] and remove [j]
        if 'laine' in file and interval.text == 'j' and tg['SOUND'][count - 1].text == 'a':
            index_no = count # save index of this interval, as this will be needed to save the new one
            new_boundary = interval.xmax # get time of right boundary of this interval
            removed_interval = tg['SOUND'].pop(count) # remove this interval
            tg['SOUND'][index_no - 1].xmax = new_boundary # over-write the previous interval's right boundary with the one from the removed interval
            tg['SOUND'][index_no - 1].text = 'e'
            
            
        # l'anis and l'apis - add [s]
        if ('lanis' in file and tg['SOUND'][count - 1].text == 'n') or ('lapis' in file and tg['SOUND'][count - 1].text == 'p'):
            index_no = count # save index of this interval, as this will be needed to add the new one
            duration_proportion = interval.xmin + interval.dur * 0.67 # define the boundary between the current interval and its new neighbour to the right as a certain proportion of its current duration
            tg['SOUND'].insert(index_no + 1, textgrids.Interval(text = 's', xmin = duration_proportion, xmax = interval.xmax)) # insert a new interval to the right of the current interval, using the proportion defined earlier as its left boundary, and the right boundary of the current interval as its right boundary
            interval.xmax = duration_proportion # update the right boundary of the current interval to match the left boundary of its new neighbour to the right
            
        
        # simple transcription fixes (redundant as used elsewhere)
        fix_sound_syllable(interval)
      
    
    
    ## syllable tier
    for count, interval in enumerate(tg['SYLLABLE']):
    
        # yack part 1 - replace [i] with [j] - this might be redundant
        if 'yack' in file and interval.text != 'd i': # avoid 'i' in 'dis' and 'samedi'
            interval.text = interval.text.replace('i', 'j')
            
        # l' - remove schwa [@] syllable
        # This section messes up the result of the fix_sound_syllable() function.
        # The whole script works if you apply the function elsewhere, as I have
        # done, but ideally this part should be edited so that it doesn't cause
        # problems with the function.
        if interval.text == 'l' or interval.text == 'l @': # if those intervals appear...
            index_no = count # save index of this interval, as this will be needed to save the new one
            new_boundary = interval.xmin # get time of left boundary of this interval
            removed_interval = tg['SYLLABLE'].pop(count) # remove this interval
            tg['SYLLABLE'][index_no].text = 'l ' + tg['SYLLABLE'][index_no].text # over-write the text of the interval at the same index (the one to the right of the old one, now moved up a slot) as [l target]
            tg['SYLLABLE'][index_no].xmin = new_boundary # over-write that interval's left boundary with the one from the removed interval
            
        # samedi - remove schwa [@] syllable and move [m] to the previous syllable
        if interval.text == 'm @' and tg['SYLLABLE'][count - 1].text == 's a': # if those intervals appear...
            index_no = count # save index of this interval, as this will be needed to save the new one
            new_boundary = interval.xmax # get time of right boundary of this interval
            removed_interval = tg['SYLLABLE'].pop(count) # remove this interval
            tg['SYLLABLE'][index_no - 1].text = 's a m' # over-write the previous interval's text as 's a m'
            tg['SYLLABLE'][index_no - 1].xmax = new_boundary # over-write the previous interval's right boundary with the one from the removed interval
            
        # yack part 2- remove separate [a k] syllable and move these sounds to the previous syllable
        if interval.text == 'a k' and tg['SYLLABLE'][count - 1].text == 'j': # if those intervals appear...
            index_no = count # save index of this interval, as this will be needed to save the new one
            new_boundary = interval.xmax # get time of right boundary of this interval
            removed_interval = tg['SYLLABLE'].pop(count) # remove this interval
            tg['SYLLABLE'][index_no - 1].text = 'j a k ' # over-write the previous interval's text as 'j a k'
            tg['SYLLABLE'][index_no - 1].xmax = new_boundary # over-write the previous interval's right boundary with the one from the removed interval
            
            
        # l'enfer - replace [e] with [E] and add [R]
        if 'lenfer' in file:
            interval.text = interval.text.replace('f e', 'f E R')
            interval.text = interval.text.replace('f E R t', 'f E R')
            
        # l'anis and l'apis - add [s]
        if (interval.text == 'n i' and 'lanis' in file) or (interval.text == 'p i' and 'lapis' in file):
            interval.text = interval.text.replace('n i', 'n i s')
            interval.text = interval.text.replace('p i', 'p i s')
            
        # simple transcription fixes (redundant as used elsewhere)
        fix_sound_syllable(interval)
    
    # l'aîné
    # This part needs to be addressed here separately because the l' part above
    # causes problems with the relevant line in the fix_sound_syllable() function.
    # re.match is used because the whole interval.text needs replacing.
    for interval in tg['SYLLABLE']:
        if 'laine' in file and re.match(r'.+j', interval.text):
            interval.text = 'l e'


    ### End of specific interval changes
    

    # Over-write the TextGrid  
    tg.write(source_path + file)
    
    # Print a message to check that the file has been successfully processed
    print('Successfully processed {}!'.format(file))